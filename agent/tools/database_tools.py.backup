"""
Datab√°zov√© n√°stroje - SQLite a Vector DB s pr√°vnymi pojmami
"""

from typing import List, Dict, Any, Optional, Type
from langchain.tools import BaseTool
from pydantic import Field
import sqlite3
import os
import json
import re

# Fallback pre ChromaDB ak nie je dostupn√©
try:
    import chromadb
    CHROMADB_AVAILABLE = True
except ImportError:
    CHROMADB_AVAILABLE = False


class LegalTermSearchTool(BaseTool):
    """N√°stroj pre vyhƒæad√°vanie pr√°vnych pojmov v datab√°ze"""
    
    name: str = "legal_term_search"
    description: str = """
    Vyhƒæad√°va defin√≠cie pr√°vnych pojmov v datab√°ze slovensk√Ωch z√°konov.
    U≈æitoƒçn√© keƒè pou≈æ√≠vateƒæ p√Ωta na v√Ωznam pr√°vnych term√≠nov alebo chce vysvetlenie pojmov.
    Podporuje fuzzy vyhƒæad√°vanie a synonym√°.
    Input: kƒæ√∫ƒçov√© slov√° alebo pojmy na vyhƒæadanie (string)
    """
    
    # Pydantic fields
    db_path: str = Field(default="data/legal_terms.db")
    
    def __init__(self, db_path: str = "data/legal_terms.db", **kwargs):
        super().__init__(db_path=db_path, **kwargs)
    
    def extract_keywords(self, query: str) -> List[str]:
        """Extrahuje kƒæ√∫ƒçov√© slov√° z pou≈æ√≠vateƒæsk√©ho dotazu"""
        # Odstr√°≈à be≈æn√© slov√°
        stop_words = {
            'ƒço', 'je', 'to', 'ako', 'kde', 'kedy', 'preƒço', 'ak√Ω', 'ak√°', 'ak√©',
            'ktor√Ω', 'ktor√°', 'ktor√©', 'm√¥≈æe', 'm√¥≈æem', 'sa', 'si', 'ma', 'mi',
            'na', 'do', 'od', 'za', 'pre', 'pod', 'nad', 'o', 'v', 'vo', 'k', 'ku',
            'a', 'ale', 'alebo', 'ani', 'v≈°ak', '≈æe', 'aby', 'keƒè', 'ak', 'ƒçi',
            'znamen√°', 'defin√≠cia', 'pojem', 'term√≠n', 'vysvetli', 'objasni'
        }
        
        # Tokenizuj a vyƒçisti
        words = re.findall(r'\b\w+\b', query.lower())
        keywords = [word for word in words if word not in stop_words and len(word) > 2]
        
        # Pridaj aj p√¥vodn√© fr√°zy s viacer√Ωmi slovami
        phrases = []
        if 's ruƒçen√≠m obmedzen√Ωm' in query.lower():
            phrases.append('spoloƒçnos≈• s ruƒçen√≠m obmedzen√Ωm')
        if 'pr√°vnick√° osoba' in query.lower():
            phrases.append('pr√°vnick√° osoba')
        if 'fyzick√° osoba' in query.lower():
            phrases.append('fyzick√° osoba')
        
        return keywords + phrases
    
    def _run(self, query: str) -> str:
        """Vyhƒæadaj pr√°vne pojmy"""
        try:
            # Extrahuj kƒæ√∫ƒçov√© slov√°
            keywords = self.extract_keywords(query)
            
            if not keywords:
                return "Neboli n√°jden√© relevantn√© kƒæ√∫ƒçov√© slov√° v dotaze."
            
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            # Vyhƒæad√°vanie s fuzzy matching
            results = []
            for keyword in keywords[:3]:  # Max 3 kƒæ√∫ƒçov√© slov√°
                cursor.execute("""
                    SELECT term, definition, law_id, paragraph, confidence, category
                    FROM legal_terms 
                    WHERE term LIKE ? OR definition LIKE ?
                    ORDER BY confidence DESC, LENGTH(term) ASC
                    LIMIT 3
                """, (f"%{keyword}%", f"%{keyword}%"))
                
                keyword_results = cursor.fetchall()
                for result in keyword_results:
                    if result not in results:  # Vyvaruj sa duplicit√°m
                        results.append(result)
            
            conn.close()
            
            if not results:
                return f"Nena≈°li sa defin√≠cie pre: {', '.join(keywords)}"
            
            # Form√°tuj v√Ωsledky
            response = f"üîç N√°jden√© defin√≠cie pre: {', '.join(keywords)}\n\n"
            
            for i, (term, definition, law_id, paragraph, confidence, category) in enumerate(results[:5], 1):
                response += f"{i}. **{term}** ({category})\n"
                response += f"   üìç {law_id}"
                if paragraph:
                    response += f" {paragraph}"
                response += f"\n"
                response += f"   üìù {definition}\n"
                response += f"   üéØ Spoƒæahlivos≈•: {confidence:.1f}/1.0\n\n"
            
            return response.strip()
            
        except sqlite3.Error as e:
            return f"Chyba datab√°zy: {e}"
        except Exception as e:
            return f"Chyba pri vyhƒæad√°van√≠: {e}"


class VectorSearchTool(BaseTool):
    """N√°stroj pre s√©mantick√© vyhƒæad√°vanie v pr√°vnych dokumentoch"""
    
    name: str = "vector_search"
    description: str = """
    Vyhƒæad√°va relevantn√© pr√°vne dokumenty pomocou s√©mantick√©ho vyhƒæad√°vania v ChromaDB datab√°ze.
    Datab√°za obsahuje nasledovn√© slovensk√© z√°kony:
    - 40/1964 - Obƒçiansk√Ω z√°konn√≠k
    - 513/1991 - Obchodn√Ω z√°konn√≠k  
    - 530/2003 - Z√°kon o spr√°vnom s√∫dnictve
    - 300/2005 - Trestn√Ω z√°kon
    - 160/2015 - Civiln√Ω sporov√Ω poriadok
    - 161/2015 - Civiln√Ω mimosporov√Ω poriadok
    
    Najlep≈°√≠ n√°stroj pre hƒæadanie konkr√©tnych ustanoven√≠, paragrafov alebo pr√°vnych konceptov v textoch t√Ωchto z√°konov.
    Input: vyhƒæad√°vac√≠ dotaz alebo kƒæ√∫ƒçov√© slov√° (string)
    """
    
    # Pydantic fields
    collection_name: str = Field(default="legal_documents")
    client: Optional[Any] = Field(default=None, exclude=True)
    collection: Optional[Any] = Field(default=None, exclude=True)
    embedding_function: Optional[Any] = Field(default=None, exclude=True)
    multilingual_embedding_function: Optional[Any] = Field(default=None, exclude=True)
    
    def __init__(self, collection_name: str = "legal_documents", **kwargs):
        super().__init__(collection_name=collection_name, **kwargs)
        if CHROMADB_AVAILABLE:
            try:
                # Vytvor PRESNE ROVNAK√ù embedding model ako pri vytv√°ran√≠ datab√°zy
                try:
                    from sentence_transformers import SentenceTransformer
                    
                    # Vytvor embedding funkciu IDENTICK√ö s load_law_texts.py
                    class MultilingualEmbeddingFunction:
                        def __init__(self, model_name):
                            from sentence_transformers import SentenceTransformer
                            self.model = SentenceTransformer(model_name)
                            self.model_name = model_name  # Pridaj n√°zov modelu
                            self.name = f"multilingual-{model_name}"  # ChromaDB name atrib√∫t
                        
                        def __call__(self, input):
                            import numpy as np
                            
                            # Z√≠skaj embeddings
                            embeddings = self.model.encode(input)
                            
                            # Normalizuj PRESNE ako v load_law_texts.py
                            if len(embeddings.shape) == 1:
                                # Jeden vektor
                                norm = np.linalg.norm(embeddings)
                                if norm > 0:
                                    embeddings = embeddings / norm
                            else:
                                # Viac vektorov
                                norms = np.linalg.norm(embeddings, axis=1, keepdims=True)
                                embeddings = embeddings / np.maximum(norms, 1e-8)
                            
                            return embeddings.tolist()
                    
                    # Pou≈æ√≠vame PRESNE ROVNAK√ù model ako v datab√°ze
                    self.multilingual_embedding_function = MultilingualEmbeddingFunction("paraphrase-multilingual-MiniLM-L12-v2")
                    
                    self.client = chromadb.PersistentClient(path="data/vector_db")
                    print("‚úÖ ChromaDB klient s multilingual embedding modelom (paraphrase-multilingual-MiniLM-L12-v2)")
                    
                except ImportError:
                    print("‚ùå Sentence transformers nie s√∫ dostupn√© - potrebn√© pre multilingual model")
                    self.client = None
                    self.embedding_function = None
                
                self._init_collection()
            except Exception as e:
                print(f"‚ùå Chyba pri inicializ√°cii ChromaDB: {e}")
                self.client = None
                self.collection = None
        else:
            self.client = None
            self.collection = None
    
    def _init_collection(self):
        """Inicializuje existuj√∫cu vector collection bez zmien"""
        if not self.client:
            return
            
        try:
            # Skontroluj dostupn√© kolekcie
            try:
                collections = self.client.list_collections()
                collection_names = [col.name for col in collections]
                
                if self.collection_name not in collection_names:
                    print(f"‚ùå Collection '{self.collection_name}' neexistuje")
                    print(f"üìã Dostupn√© kolekcie: {collection_names}")
                    print("üí° Spustite: python scripts/load_law_texts.py")
                    self.collection = None
                    self.embedding_function = None
                    return
                    
            except Exception as e:
                print(f"‚ö†Ô∏è Probl√©m pri naƒç√≠tavan√≠ zoznamu kolekci√≠: {e}")
            
            # Najprv naƒç√≠taj kolekciu bez embedding funkcie (kompatibilita)
            self.collection = self.client.get_collection(name=self.collection_name)
            count = self.collection.count()
            
            # Potom nastav embedding function pre query oper√°cie
            if hasattr(self, 'multilingual_embedding_function') and self.multilingual_embedding_function:
                self.embedding_function = self.multilingual_embedding_function
                print("‚úÖ Collection naƒç√≠tan√° a embedding funkcia nastaven√°")
            else:
                self.embedding_function = None
                print("‚ö†Ô∏è Collection naƒç√≠tan√° bez custom embedding funkcie")
            
            if count > 0:
                print(f"‚úÖ Naƒç√≠tan√° produkƒçn√° datab√°za s {count} dokumentmi")
                
                # Kr√°tky test funkƒçnosti len ak m√°me embedding function
                if self.embedding_function:
                    try:
                        # Test s na≈°ou embedding funkciou
                        test_embedding = self.embedding_function(["test vlastn√≠ctvo"])
                        test_results = self.collection.query(
                            query_embeddings=test_embedding,
                            n_results=1,
                            include=["distances"]
                        )
                        
                        if test_results["distances"][0]:
                            distance = test_results["distances"][0][0]
                            similarity = round((1 - distance) * 100, 1)
                            print(f"‚úÖ Vector search je funkƒçn√Ω (test similarity: {similarity}%)")
                        
                    except Exception as e:
                        print(f"‚ö†Ô∏è Warning pri teste embedding: {e}")
                
            else:
                print("‚ö†Ô∏è Collection existuje ale je pr√°zdna")
                print("ÔøΩ Spustite: python scripts/load_law_texts.py")
                
        except Exception as e:
            print(f"‚ùå Chyba pri naƒç√≠tavan√≠ collection '{self.collection_name}': {e}")
            print("üí° Najprv spustite: python scripts/load_law_texts.py")
            self.collection = None
            self.embedding_function = None
    
    def _run(self, query: str) -> str:
        """Vyhƒæadaj podobn√© dokumenty pomocou rovnak√©ho embedding modelu"""
        if not self.collection:
            return f"Vector search nie je dostupn√Ω - kolekcia '{self.collection_name}' neexistuje. Najprv spustite: python scripts/load_law_texts.py"
            
        try:
            # Pou≈æi≈• na≈°u embedding funkciu pre query (rovnak√Ω model ako datab√°za)
            if hasattr(self, 'embedding_function') and self.embedding_function:
                # Vytvor embedding pre query pomocou n√°≈°ho modelu
                query_embedding = self.embedding_function([query])
                
                # Vyhƒæadaj pomocou embedding vektora
                results = self.collection.query(
                    query_embeddings=query_embedding,
                    n_results=5,
                    include=["documents", "metadatas", "distances"]
                )
            else:
                # Ak nem√°me embedding funkciu, nem√¥≈æeme vyhƒæad√°va≈• kompatibilne
                return f"Embedding model nie je dostupn√Ω pre dotaz: {query}. Skontrolujte in≈°tal√°ciu sentence-transformers a spustite: python scripts/load_law_texts.py"
            
            if not results["documents"][0]:
                return f"Nena≈°li sa ≈æiadne relevantn√© dokumenty pre: {query}"
            
            formatted_results = []
            for i, (doc, metadata, distance) in enumerate(zip(
                results["documents"][0],
                results["metadatas"][0],
                results["distances"][0]
            )):
                similarity = round((1 - distance) * 100, 1)
                
                # Z√≠skaj √∫daje z metad√°t
                law_id = metadata.get('law_id', metadata.get('zakon', 'N/A'))
                paragraph = metadata.get('paragraph', f"¬ß {metadata.get('paragraf', 'N/A')}")
                title = metadata.get('title', metadata.get('tema', ''))
                
                formatted_results.append(
                    f"**V√Ωsledok {i+1}** (podobnos≈•: {similarity}%)\n"
                    f"Z√°kon: {law_id} - {paragraph}\n"
                    f"N√°zov: {title}\n"
                    f"Text: {doc[:300]}{'...' if len(doc) > 300 else ''}\n"
                )
            
            return "\n".join(formatted_results)
            
        except Exception as e:
            return f"Chyba pri vector vyhƒæad√°van√≠: {str(e)}"
    
    async def _arun(self, query: str) -> str:
        """Async verzia"""
        return self._run(query)


def get_database_tools():
    """Vr√°ti zoznam v≈°etk√Ωch datab√°zov√Ωch n√°strojov"""
    return [
        LegalTermSearchTool(),  # Tool pre vyhƒæad√°vanie pr√°vnych pojmov
        # VectorSearchTool() nahraden√Ω enhanced verziou v legal_agent.py
    ]
